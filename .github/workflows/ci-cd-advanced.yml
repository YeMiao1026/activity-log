name: CI/CD Advanced Pipeline

on:
  workflow_dispatch:
    inputs:
      bump:
        description: 'semantic bump (major/minor/patch) or none'
        required: false
        default: 'patch'
  push:
    branches: [ main ]

jobs:
  # ----------------------------
  # 1) Test (matrix) - lint & unit tests (simulated)
  # ----------------------------
  test:
    name: Test matrix (Node ${{ matrix.node }})
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: [18, 20]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}

      - name: Install deps
        run: npm install

      - name: Lint (simulated)
        run: echo "‚úÖ Simulated lint passed successfully."

      - name: Unit tests (simulated)
        run: echo "‚úÖ Simulated unit tests passed successfully."

  # ----------------------------
  # 2) Build - depends on tests
  # ----------------------------
  build:
    name: Build artifact
    needs: test
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.getver.outputs.version }}
    steps:
      - name: Checkout (full)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0                # needed for git describe & tags

      - name: Setup Node (build)
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install
        run: npm install               # use npm install (no package-lock requirement)

      - name: Simulated build (or real build)
        run: |
          echo "üîß Building..."
          mkdir -p dist
          echo "<h1>CI/CD Build</h1>" > dist/index.html
          zip -r build.zip dist

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-artifact
          path: build.zip

      - name: Get version from package.json or git tag
        id: getver
        run: |
          if [ -f package.json ]; then
            ver=$(node -p "require('./package.json').version")
            echo "version=$ver" >> $GITHUB_OUTPUT
          else
            ver=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
            echo "version=$ver" >> $GITHUB_OUTPUT
          fi

  # ----------------------------
  # 3) Optional bump (semantic) - only when requested
  # ----------------------------
  bump:
    name: Semantic bump (optional)
    needs: build
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.bump != 'none' }}
    steps:
      - name: Checkout (for tag push)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Bump package.json version
        env:
          BUMP: ${{ github.event.inputs.bump }}
        run: |
          npm version $BUMP -m "chore(release): %s [skip ci]"

      - name: Push tags and commits
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git push origin HEAD --follow-tags

  # ----------------------------
  # 4) Deploy to Staging
  # ----------------------------
  deploy-staging:
    name: Deploy ‚Üí Staging
    needs: build                     # only requires build; bump is optional
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: build-artifact

      - name: Prepare tag
        id: tagstg
        run: |
          if [ -f package.json ]; then
            ver=$(node -p "require('./package.json').version")
          else
            ver=${{ needs.build.outputs.version }}
          fi
          TAG="staging-v${ver}"
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Create staging release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NOTE_BASE: ${{ vars.RELEASE_NOTE }}
        run: |
          TAG="${{ steps.tagstg.outputs.tag }}"
          NOTE="$NOTE_BASE - Testing pre-production release on $(date -u)"
          echo "Creating release $TAG"
          gh release create "$TAG" build.zip --notes "$NOTE"
          echo "created: $TAG"

      - name: Notify Slack (staging)
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_STAGING }}
        run: |
          if [ -n "$SLACK_WEBHOOK" ]; then
            payload='{"text":"Staging release created: '${{ steps.tagstg.outputs.tag }}'"}'
            curl -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK"
          else
            echo "‚ö†Ô∏è No Slack webhook configured for staging, skipping notification."
          fi

  # ----------------------------
  # 5) Deploy to Production (requires environment approval)
  # ----------------------------
  deploy-production:
    name: Deploy ‚Üí Production
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment: production   # production environment must have reviewers set
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: build-artifact

      - name: Prepare production tag
        id: tagprod
        run: |
          if [ -f package.json ]; then
            ver=$(node -p "require('./package.json').version")
          else
            ver=${{ needs.build.outputs.version }}
          fi
          TAG="prod-v${ver}"
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Create production release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NOTE_BASE: ${{ vars.RELEASE_NOTE }}
        run: |
          TAG="${{ steps.tagprod.outputs.tag }}"
          NOTE="$NOTE_BASE - Production release on $(date -u)"
          echo "Creating production release $TAG"
          gh release create "$TAG" build.zip --notes "$NOTE"
          echo "created: $TAG"

      - name: Notify Slack (production)
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_PROD }}
        run: |
          if [ -n "$SLACK_WEBHOOK" ]; then
            payload='{"text":"Production release published: '${{ steps.tagprod.outputs.tag }}'"}'
            curl -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK"
          else
            echo "‚ö†Ô∏è No Slack webhook configured for production, skipping notification."
          fi

  # ----------------------------
  # 6) Rollback / cleanup (runs on failure)
  # ----------------------------
  cleanup:
    name: Cleanup on failure
    needs: [deploy-staging, deploy-production]
    runs-on: ubuntu-latest
    if: ${{ failure() }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Find and delete failed releases
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "One of the deployment jobs failed ‚Äî attempting to clean up releases created in this run"
          for t in $(gh release list --limit 50 --json tagName --jq '.[].tagName'); do
            if [[ "$t" == staging-v* || "$t" == prod-v* ]]; then
              echo "Deleting release $t"
              gh release delete -y "$t" || true
              git push origin --delete "$t" || true
            fi
          done
